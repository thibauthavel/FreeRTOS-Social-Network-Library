Teesside University
School of Computing
2011 - 2012

Final Year Project
BSc Computer Science

Social network library development
Thibaut Havel
L1247434

Supervisor: Jo˜o F. Ferreira
a
Second reader: Erika Downs

Abstract
The main aim of this project is to develop a low-level library that is able to grab and store
data from a social network. This library was designed for embedded devices and allows data to
be stored and to be used to provide a simple service. To demonstrate the eﬀectiveness of the ﬁnal
library, I created a demo service that interacts with a known social network (for example, Twitter).

1

Acknowledgements
I would like to thank my supervisor Jo˜o Ferreira for his support all over the development
a
of my project.

2

Contents
1 Introduction

5

2 Methodology

6

2.1

The initial project scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.2

Research plan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.3

The support tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

7

3 Research
3.1

8
8

3.1.1

Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8

3.1.2

Real-Time System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8

3.1.3

Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

3.1.4

POSIX simulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

Twitter authentication: OAuth protocol . . . . . . . . . . . . . . . . . . . . . . . . .

10

3.2.1

Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

3.2.2

Existing library in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

3.2.3

Register an application on Twitter . . . . . . . . . . . . . . . . . . . . . . . .

10

3.2.4

3.2

Operating System: FreeRTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Required libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

4 Design of the library
4.1

11
11

4.1.1

Interactions with Twitter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11

4.1.2
4.2

Functional design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Easy layer to user . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11

Implementation design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12

3

4.2.1

Functions implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12

4.2.2

Functional diagram of the library . . . . . . . . . . . . . . . . . . . . . . . . .

13

5 Implementation
5.1

14
14

5.1.1

Required libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14

5.1.2

Authentication process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14

5.1.3

Send a tweet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14

5.1.4
5.2

The library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Receive a tweet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14

A demo application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14

6 Testing of the library

15

7 Evaluation of the ptoject

16

7.1

Goal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

16

7.2

Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

16

7.3

Improvements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

16

8 Conclusion

17

4

1

Introduction

Our society tends to use more and more social networks (for instance, Twitter or Facebook).
At the same time, we are increasingly dependent on the use of embedded devices on a day-to-day
basis (for instance, home automation). The goal of this project is to develop a software platform
that allows an eﬀective and eﬃcient communication between embedded devices and social networks.
The main aim is to develop a low-level library that is able to grab and store data from a
social network. This library was designed for embedded devices and allows data to be stored and to
be used to provide a simple service. To demonstrate the eﬀectiveness of the ﬁnal library, I created a
demo service that interacts with a known social network: Twitter.
One of my personal objectives was to improve my knowledge in low-level development and
become familiar with the C language. Also I was looking forward to improving my software development skill while working with a very speciﬁc hardware.
Firstly, this report will present the way I started my initial research and how I designed
the library according to my functional choices. Secondly, it will present how I’ve implemented these
functionalities, and what I did to test my library. Finally, this report will end by an evaluation of
the ﬁnal product regarding the design choices, the way I’ve implemented them, and his reliability.

5

2

Methodology

2.1

The initial project scheduling
In my project speciﬁcation, I set my schedule as following:

•
•
•
•

January: Research (2 weeks), design (2 weeks).
Febuary: Design (1 week), Implementation (3 weeks).
March: Implementation (3 weeks), Testing (1 week).
April: Evaluation and report compilation (2 weeks).

My supervisor Jo˜o and I met every week or every two weeks to discuss about the planning
a
and progresses of my project.

2.2

Research plan

My initial approach was to become familiar with the embedded device technology. I had to
ﬁnd an adapted, a small and a simple operating system to work with, thereby I chose FreeRTOS1
supported from my supervisor.
My supervisor had already used this system and he had developed applications before. He
provided me one of his own device running with FreeRTOS. So, thanks to Jo˜o and his knowledge
a
about this operating system, I had a platform in addition to a massive support from him and the
online community to develop my library. As I didn’t have any knowledge about FreeRTOS, I read
several articles which deals with how it works, and how tasks are scheduled in an real-time way.
As a consequence of this chose and because one the goals of this project is to gain knowledge
about low-level development, the library has been built using the C language.
Then, I deﬁned every functionality of the ﬁnal applications. Basically, the library’s features
are simple: it should allow a user to receive and send text from and to a social network. For instance
1

FreeRTOS is a light-weight Real-Time Operating System.

6

a message on the wall in Facebook or a tweet in Twitter. Facebook and Twitter are both well
known social networks and after some research about them, I choose to build my library suitable for
Twitter because of the solid support for OAuth which is a secured protocol to access data. Once
again, this choice was supported by Jo˜o.
a
At this point, I had to deﬁned how to receive and to send tweets, so I’ve started by looking
for any existing solutions. In the next chapter, I will discuss why I chose to build my own library
from scratch only using OAuth.
After this key decision, I’ve learned how OAuth works and how to register an application on
Twitter it in order to access to the data.
As I was now aware about what the tools I will use and the way to use them, I designed the
library according to the features I wanted to implement.
The next step of the development was to implement the abstract structure of the library. At
this stage, I faced lot of issues concerning the use of OAuth, the C language and its requirements.
During my previous years of studies I learnt the basics of this language but to build the library I
read a lot of articles, books and tutorials along the implementation.
Once I ﬁnished the draft version of the library, I tested every functionality by receiving and
sending tweets over my own account and I improved the reliability according to the results of these
tests.

2.3

The support tools

To help myself into the research and the development of the library, I used some additional
appropriate tools:
• A diary: to keep every relevant informations but also as a memory trail of the development
chronology.
• Github2 : to back up the source code and share my progress with my supervisor.
• FreeRTOS POSIX3 simulator: to develop and to test my library without any embedded device.

2
3

Github is an online project hosting.
Standards to maintaining compatibility between UNIX operating systems.

7

3

Research

3.1

Operating System: FreeRTOS

3.1.1

Overview

FreeRTOS is a light-weight and real-time1 operating system suitable for embedded devices. It
is distributed under the GPL2 even then with certain exceptions: a developer is required to maintain
the kernel as open source, whereas he could remain closed source his applications.

Figure 3.1: FreeRTOS logo
The FreeRTOS source code is tiny and simple, thus it is really easy to port. It is mostly
written in C and assembly. The kernel has been ported to around thirty micro-controllers.

3.1.2

Real-Time System

One of the main feature provided by FreeRTOS is the way the system performs threads. All
tasks are scheduled depending on their priority and sorted according to a round-robin algorithm.
Every ﬁles which manage tasks should include the FreeRTOS header task.h in order to use
the appropriate functions.
A task can be deﬁned as follows and should be of endless loop style:

1
2

A system that should ﬁt to time constraints.
General public licence is used for free and open source software.

8

1
2
3
4
5
6
7

v o i d vMyTask ( v o i d ∗ pvParameters )
{
for ( ; ; )
{
/∗ Task code c o n t e n t ∗/
}
}

The FreeRTOS thread API3 allows to manage tasks. For instance, to create or delete them:
1

xTaskHandle xHandle ;

2
3
4

xTaskCreate ( vMyTask , ”NAME” , STACK SIZE , &parameters , tskIDLE PRIORITY , &xHandle ) ;
vTaskDelete ( xHandle ) ;

The xTaskHandle element allows to keep a reference to the task that can be then used by other
functions
Depending on its presence or its position in the queue, a task can take diﬀerent states:
• Ready: the task is ready to run but it is not currently executing because another task is
running. From this state, it might become Suspended or Running.
• Running: this task is currently executing. From this state, it might become Blocked, Ready or
Suspended.
• Blocked: this task is not available for scheduling until a deﬁned delay period. From this state,
it might become Suspended or Ready.
• Suspend: this task is not available for scheduling without any timeout. From this state, it
might become Ready.
These states can be changed using the appropriate functions from the API, for instance:
1
2

/∗ To suspend a s p e c i f i c t a s k ∗/
vTaskSuspend ( xHandle ) ;

3
4
5

/∗ To resume a suspended t a s k ∗/
vTaskResume ( xHandle ) ;

6
7
8

/∗ To r a i s e a t a s k p r i o r i t y ∗/
v T a s k P r i o r i t y S e t ( xHandle , tskIDLE PRIORITY + 1 ) ;
3

An Application Programming Interface is a set of routines or functions given by a library.

9

3.1.3

3.2
3.2.1

POSIX simulator

Twitter authentication: OAuth protocol
Overview

(Common authentication mechanism: token, secret key system, include graphic representations)

3.2.2

Existing library in C

(Downloaded and tested library: samples hard to understand, idea: create a simple-to-use library
layer)

3.2.3

Register an application on Twitter

(Way and proprieties of the registered application)

3.2.4

Required libraries

(libcurl: overview and it’s seem hard to adapt to FreeRTOS, idea: create a very simple HTTP request
library)
(OpenSSL: overview and it’s seem hard to adapt to FreeRTOS, idea)

10

4

Design of the library

4.1

Functional design

4.1.1

Interactions with Twitter
Basically, the ﬁnal library should allow a developer:

• To authenticate its application to Twitter.
• To send tweets to Twitter.
• To receive tweets from Twitter.
And these features have to work whatever the operating system and the hardware architecture.
I chose not implement any storing properties because it is more ﬂexible to let the developer
chose the way he wants to store tweets.

4.1.2

Easy layer to user

This library has to be a user-friendly layer. The developer does not have to know how OAuth
works to build its own application to access to Twitter. He just have to give the basic informations
about the registered application (the public and secret key provided by Twitter) and informations
about its Twitter account (the login and password).
The ﬁrst main functionality is the authentication process which gathers all OAuth operations
and returns an authentication entity (for instance, typed as a C structure) which could be use by
the developer in a further step to send and to receive tweets. This entity contains every required
informations needed to allow OAuth to connect to Twitter.
The send functionality is one of the two behaviours which could use the authentication entity
in order to send a tweet on a Twitter proﬁle.

11

Finally, the receive functionality use the authentication entity as well in order to receive
tweets from a Twitter account’s timeline1 . This functionality include parsing functions which allows
to return a set of tweets entities.
Each functionality is represented by a single function. Nevertheless, the content of a functionality could be split into several operation each represented by another function.

4.2

Implementation design

4.2.1

Functions implementations

Every steps of the authentication process are gather into the main authentication function.
Basically each use of the OAuth library for a speciﬁc stage of the synchronisation is surrounded by a
set of operations, for this very reason each stage is deﬁned into a distinctive function. As explained
above in the chapter Research, to authenticate an application to Twitter and then be able to access
to the timeline or to send a tweet is simple but it requires few steps:
•
•
•
•

1- Request token: it requests the ﬁrst token to the Twitter service provider.
2- Direct token: it requests the token needed to obtain user authorization.
3- Veriﬁer: it uses the direct token in order to request the PIN code (or veriﬁer).
4- Access token: it uses the veriﬁer to request the ﬁnal token which will be use to send or
receive tweets.

This main function gives to the user an authentication entity, that is the one he provides to the
behaviour functions (send and receive). This entity is typed as a C structure.
As every behaviour functions, the send function need the access token to be able to send a text
message over Twitter. The main function retrieves the needed informations from the authentication
entity which are given as parameters in sub-functions2 . Whatever the sub-function, no ﬁeld of the
authentication entity is directly used, only the main function holds this responsibility.
To get the tweets from the user’s timeline, a request is ﬁrstly send to the Twitter service
provider. The result is a XML content which is parsed by some sub-functions. These parsing
functions determine how many tweets are there in the timeline, and for each of them a new structure
is created. Thus, the main function gives to the developer a collection of tweets each represented
by a C structure which contains the most signiﬁcant informations about it (e.g. the date, the text
content).
1
2

The timeline is the part of a Twitter proﬁle which contains all tweets sent by a user.
A sub-function is used by the main function in a distributed way to perform the goal.

12

4.2.2

Functional diagram of the library

Figure 4.1: Functional diagram representing the implemented design

13

5

Implementation

5.1

The library

5.1.1

Required libraries

- OAuth which use OpenSSL and Libcurl are required. - OAuth and OpenSSL could be both included
in the ﬁnal library package. - The use of Libcurl could be replace by sockets.

5.1.2

Authentication process

- Request token - Direct token - Access token - Authentication structure returned

5.1.3

Send a tweet

- How use the authentication structure - Apply these informations to a behaviour

5.1.4

Receive a tweet

- Receiving process - XML parsing: get each tweet - Store temporary informations as a structure

5.2

A demo application

(Graphic representation of the use of my library layer)

14

6

Testing of the library

15

7

Evaluation of the ptoject

7.1

Goal

(Is my goal achieved, why/why not?)
(Is my work could be use by someone else, why/why not?)

7.2

Schedule

(Did I follow my schedule, why/why not?)

7.3

Improvements

(What is it possible to do to improve my library?)

16

8

Conclusion

17

Bibliography
[1] F. Surname, “Title,” 2000.
[2] D. E. Knuth, The TEXbook. Addison-Wesley, 1990.

18

