Teesside University
School of Computing
2011 - 2012

Final Year Project
BSc Computer Science

Social network library development
Thibaut Havel
L1247434

Supervisor: Jo˜o F. Ferreira
a
Second reader: Erika Downs

Abstract
The main aim of this project is to develop a low-level library that is able to grab and store
data from a social network. This library was designed for embedded devices and allows data to
be stored and to be used to provide a simple service. To demonstrate the eﬀectiveness of the ﬁnal
library, I created a demo service that interacts with a known social network (for example, Twitter).

1

Acknowledgements
I would like to thank my supervisor Jo˜o Ferreira for his support all over the development
a
of my project.

2

Contents
1 Introduction

5

2 Methodology

6

2.1

The initial project scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.2

Research plan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

6

2.3

The support tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

7

3 Research
3.1

8
8

3.1.1

Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8

3.1.2

Real-Time System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8

3.1.3

POSIX simulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

Twitter authentication: OAuth protocol . . . . . . . . . . . . . . . . . . . . . . . . .

10

3.2.1

Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

10

3.2.2

Existing library in C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

11

3.2.3

Register an application on Twitter . . . . . . . . . . . . . . . . . . . . . . . .

11

3.2.4

3.2

Operating System: FreeRTOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Required libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

12

4 Design of the library
4.1

13
13

4.1.1

Interactions with Twitter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

13

4.1.2
4.2

Functional design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

A user-friendly layer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

13

Implementation design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

14

4.2.1

14

Functions implementations . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3

4.2.2

Functional diagram of the library . . . . . . . . . . . . . . . . . . . . . . . . .

5 Implementation

15
16

5.1

Required libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

16

5.2

Authentication process . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

17

5.3

Send a tweet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

18

5.4

Receive a tweet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

18

6 Testing of the library

19

7 Evaluation of the project

20

7.1

Goal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

20

7.2

Schedule . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

20

7.3

Improvements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

20

8 Conclusion

21

4

1

Introduction

Our society tends to use more and more social networks (for instance, Twitter or Facebook).
At the same time, we are increasingly dependent on the use of embedded devices on a day-to-day
basis (for instance, home automation). The goal of this project is to develop a software platform
that allows an eﬀective and eﬃcient communication between embedded devices and social networks.
The main aim is to develop a low-level library that is able to grab and store data from a
social network. This library was designed for embedded devices and allows data to be stored and to
be used to provide a simple service. To demonstrate the eﬀectiveness of the ﬁnal library, I created a
demo service that interacts with a known social network: Twitter.
One of my personal objectives was to improve my knowledge in low-level development and
become familiar with the C language. Also I was looking forward to improving my software development skill while working with a very speciﬁc hardware.
Firstly, this report will present the way I started my initial research and how I designed
the library according to my functional choices. Secondly, it will present how I’ve implemented these
functionalities, and what I did to test my library. Finally, this report will end by an evaluation of
the ﬁnal product regarding the design choices, the way I’ve implemented them, and his reliability.

5

2

Methodology

2.1

The initial project scheduling
In my project speciﬁcation, I set my schedule as following:

•
•
•
•

January: Research (2 weeks), design (2 weeks).
Febuary: Design (1 week), Implementation (3 weeks).
March: Implementation (3 weeks), Testing (1 week).
April: Evaluation and report compilation (2 weeks).

My supervisor Jo˜o and I met every week or every two weeks to discuss about the planning
a
and progresses of my project.

2.2

Research plan

My initial approach was to become familiar with the embedded device technology. I had to
ﬁnd an adapted, a small and a simple operating system to work with, thereby I chose FreeRTOS1
supported from my supervisor.
My supervisor had already used this system and he had developed applications before. He
provided me one of his own device running with FreeRTOS. So, thanks to Jo˜o and his knowledge
a
about this operating system, I had a platform in addition to a massive support from him and the
online community to develop my library. As I didn’t have any knowledge about FreeRTOS, I read
several articles which deals with how it works, and how tasks are scheduled in an real-time way.
As a consequence of this chose and because one the goals of this project is to gain knowledge
about low-level development, the library has been built using the C language.
Then, I deﬁned every functionality of the ﬁnal applications. Basically, the library’s features
are simple: it should allow a user to receive and send text from and to a social network. For instance
1

FreeRTOS is a light-weight Real-Time Operating System.

6

a message on the wall in Facebook or a tweet in Twitter. Facebook and Twitter are both well
known social networks and after some research about them, I choose to build my library suitable for
Twitter because of the solid support for OAuth which is a secured protocol to access data. Once
again, this choice was supported by Jo˜o.
a
At this point, I had to deﬁned how to receive and to send tweets, so I’ve started by looking
for any existing solutions. In the next chapter, I will discuss why I chose to build my own library
from scratch only using OAuth.
After this key decision, I’ve learned how OAuth works and how to register an application on
Twitter it in order to access to the data.
As I was now aware about what the tools I will use and the way to use them, I designed the
library according to the features I wanted to implement.
The next step of the development was to implement the abstract structure of the library. At
this stage, I faced lot of issues concerning the use of OAuth, the C language and its requirements.
During my previous years of studies I learnt the basics of this language but to build the library I
read a lot of articles, books and tutorials along the implementation.
Once I ﬁnished the draft version of the library, I tested every functionality by receiving and
sending tweets over my own account and I improved the reliability according to the results of these
tests.

2.3

The support tools

To help myself into the research and the development of the library, I used some additional
appropriate tools:
• A diary: to keep every relevant informations but also as a memory trail of the development
chronology.
• Github2 : to back up the source code and share my progress with my supervisor.
• FreeRTOS POSIX3 simulator: to develop and to test my library without any embedded device.

2
3

Github is an online project hosting.
Standards to maintaining compatibility between UNIX operating systems.

7

3

Research

3.1

Operating System: FreeRTOS

3.1.1

Overview

FreeRTOS is a light-weight and real-time1 operating system suitable for embedded devices. It
is distributed under the GPL2 even then with certain exceptions: a developer is required to maintain
the kernel as open source, whereas he could remain closed source his applications.

Figure 3.1: FreeRTOS logo
The FreeRTOS source code is tiny and simple, thus it is really easy to port. It is mostly
written in C and assembly. The kernel has been ported to around thirty micro-controllers.
The system kernel consists of three common main ﬁles (list.c, queue.c and tasks.c) and at
least one speciﬁc to a particular micro-controller (port.c).

3.1.2

Real-Time System

One of the main feature provided by FreeRTOS is the way the system performs threads. All
tasks are scheduled depending on their priority and sorted according to a round-robin algorithm.
Every ﬁles which manage tasks should include the FreeRTOS header task.h in order to use
the appropriate functions.
A task can be deﬁned as follows and should be of endless loop style:
1
2

A system that should ﬁt to time constraints.
General public licence is used for free and open source software.

8

1
2
3
4
5
6
7

v o i d vMyTask ( v o i d ∗ pvParameters )
{
for ( ; ; )
{
/∗ Task code c o n t e n t ∗/
}
}

The FreeRTOS thread API3 allows to manage tasks. For instance, to create or delete them:
1

xTaskHandle xHandle ;

2
3
4

xTaskCreate ( vMyTask , ”NAME” , STACK SIZE , &parameters , tskIDLE PRIORITY , &xHandle ) ;
vTaskDelete ( xHandle ) ;

The xTaskHandle element allows to keep a reference to the task that can be then used by other
functions
Depending on its presence or its position in the queue, a task can take diﬀerent states:
• Ready: the task is ready to run but it is not currently executing because another task is running.
From this state, it might become Suspended or Running.
• Running: the task is currently executing. From this state, it might become Blocked, Ready or
Suspended.
• Blocked : the task is not available for scheduling until a deﬁned delay period. From this state,
it might become Suspended or Ready.
• Suspend : the task is not available for scheduling without any timeout. From this state, it might
become Ready.
These states can be changed using the appropriate functions from the API, for instance:
1
2

/∗ To suspend a s p e c i f i c t a s k ∗/
vTaskSuspend ( xHandle ) ;

3
4
5

/∗ To resume a suspended t a s k ∗/
vTaskResume ( xHandle ) ;

6
7
8

/∗ To r a i s e a t a s k p r i o r i t y ∗/
v T a s k P r i o r i t y S e t ( xHandle , tskIDLE PRIORITY + 1 ) ;
3

An Application Programming Interface is a set of routines or functions given by a library.

9

3.1.3

POSIX simulator

To develop and test demo tasks in order to get knowledge about FreeRTOS, I worked with
a simulator. This is a ported version of the operating system that allows an embedded application
to be simulated on a computer running another system.
As I’m a Linux user, so I chose the POSIX simulator. This simulator consist of a set of ﬁles
representing the kernel and some demo applications which can all be compiled using GCC4 .
My ﬁrst attempts to use the simulator were complicated by some undeﬁned references issues
at the compilation which came from my operating system. I did managed to ﬁx the problem thanks
to my supervisor Jo˜o. At this point, I have been able to compile the simulator and to play with the
a
demo applications and even create my own one.

3.2
3.2.1

Twitter authentication: OAuth protocol
Overview

Figure 3.2: OAuth protocol: communication process

4

GNU Compiler Collection is a compiler system which can compile several programming languages including C
and C++.

10

OAuth is the secured protocol used by Twitter to allows developers to access and share data
from a third-party application. The authentication process is based on the public and private key
system. Each step of the process (from the authentication to the data access) is represented by a
granted token. The authentication consists three diﬀerent tokens:
• The Consumer token is provided by the Twitter developers website at the application referencing.
• The Request token is given by the service provider as a temporary token.
• The Access token is given as a proof of authenticity that must be use to access and share data.

3.2.2

Existing library in C

The Twitter developers documentation provides several implementations of OAuth protocol
in many languages including C++, Java or Python, but for some reason not in C. However, I found
a tiny C library under GPL, written by Robin Gareus and called liboauth. His repository gives few
examples, thus it was easy to get to know how to use it.
Basically, this library provides a set of functions to encode parameters according to OAuth
speciﬁcations and to implement the protocol using HTTP requests (GET and POST methods). For instance, these functions could be used useful to perform the granting access rights:
oauth sign url2() , oauth http get() , oauth http post() . However, the whole Twitter authentication process is really complex and could be packaged as only one main routine.

3.2.3

Register an application on Twitter

The ﬁrst step is the account registration: I created a personal account which is the same no
matter I use Twitter as a simple user sending tweets and following proﬁles, or as a developer creating
applications using the API features.
Then, I registered a new application in the Twitter developers website to get the ﬁrst required
token to use the Twitter API via OAuth. The main informations are the name of the application
and the access level: read and/or write which means that the application will be allowed to receive
and/or send tweets.
At the end of the process, Twitter gives the Consumer token (a set of a public and a private
key) and also the useful URL to send requests. These URL are static so they might be stored into
the main ﬁle that gather the whole authentication.

11

Figure 3.3: Application informations from Twitter developers website

3.2.4

Required libraries

The liboauth required two libraries: OpenSSL and libcurl, thereby to build and library that could
communicate with Twitter from an embedded device, these library must be ported and included.
OpenSSL is a open source library implementing the Secure Sockets Layer and the Transport
Layer Security protocols and including several encryption algorithms. Libcurl is a library that allows
to perform several kind of requests including FTP, IMAP, HTTP and HTTPS.
These two libraries are free open source and portable. As they could be compiled to be used
with an embedded device, they are suitable for my project.
I downloaded both of them and I checked the source code. I even tried to quickly port and
compile them to the FreeRTOS POSIX simulator, but without success. The investigation about how
to ﬁx the compilation issues should be put aside until the library fully works on the simulator.

12

4

Design of the library

4.1

Functional design

4.1.1

Interactions with Twitter
Basically, the ﬁnal library should allow a developer:

• To authenticate its application to Twitter.
• To send tweets to Twitter.
• To receive tweets from Twitter.
And these features have to work whatever the operating system and the hardware architecture.
I chose not implement any storing properties because it is more ﬂexible to let the developer
chose the way he wants to store tweets.

4.1.2

A user-friendly layer

This library has to be a user-friendly layer. The developer does not have to know how OAuth
works to build its own application to access to Twitter. He just have to give the basic informations
about the registered application (the public and secret key provided by Twitter) and informations
about its Twitter account (the login and password).
The ﬁrst main functionality is the authentication process which gathers all OAuth operations
and returns an authentication entity (for instance, typed as a C structure) which could be use by
the developer in a further step to send and to receive tweets. This entity contains every required
informations needed to allow OAuth to connect to Twitter.
The send functionality is one of the two behaviours which could use the authentication entity
in order to send a tweet on a Twitter proﬁle.

13

Finally, the receive functionality use the authentication entity as well in order to receive
tweets from a Twitter account’s timeline1 . This functionality include parsing functions which allows
to return a set of tweets entities.
Each functionality is represented by a single function. Nevertheless, the content of a functionality could be split into several operation each represented by another function.

4.2

Implementation design

4.2.1

Functions implementations

Every steps of the authentication process are gather into the main authentication function.
Basically each use of the OAuth library for a speciﬁc stage of the synchronisation is surrounded by a
set of operations, for this very reason each stage is deﬁned into a distinctive function. As explained
above in the chapter Research, to authenticate an application to Twitter and then be able to access
to the timeline or to send a tweet is simple but it requires few steps:
•
•
•
•

1- Consumer token: it is the ﬁrst token given by the Twitter service provider.
2- Request token: it requests the token needed to obtain user authorization.
3- Veriﬁer: it uses the request token in order to get the PIN code (or veriﬁer).
4- Access token: it uses the veriﬁer to request the ﬁnal token which will be use to send or
receive tweets.

This main function gives to the user an authentication entity, that is the one he provides to the
behaviour functions (send and receive). This entity is typed as a C structure.
As every behaviour functions, the send function need the access token to be able to send a text
message over Twitter. The main function retrieves the needed informations from the authentication
entity which are given as parameters in sub-functions2 . Whatever the sub-function, no ﬁeld of the
authentication entity is directly used, only the main function holds this responsibility.
To get the tweets from the user’s timeline, a request is ﬁrstly send to the Twitter service
provider. The result is a XML content which is parsed by some sub-functions. These parsing
functions determine how many tweets are there in the timeline, and for each of them a new structure
is created. Thus, the main function gives to the developer a collection of tweets each represented
by a C structure which contains the most signiﬁcant informations about it (e.g. the date, the text
content).
1
2

The timeline is the part of a Twitter proﬁle which contains all tweets sent by a user.
A sub-function is used by the main function in a distributed way to perform the goal.

14

4.2.2

Functional diagram of the library

Figure 4.1: Functional diagram representing the implemented design

15

5

Implementation

5.1

Required libraries

To be able to write the library, I ﬁrst decided to implement the dependencies: liboauth,
OpenSSL and libcurl.
I started by downloading liboauth. The content of the library is really simple because it
consists of eight C source code and header ﬁles. I managed to compile the FreeRTOS simulator
including the OAuth library: in order to do so, I ﬁrst edited the simulator makeﬁle 1 by hand.

Figure 5.1: FreeRTOS POSIX simulator, makeﬁle architecture
As shown in the ﬁgure above, the compilation instructions are gather into a Debug folder
where rules are split into sub-ﬁles. Thus, I added a subdir.mk listing the C source codes ﬁles of the
library and I referenced the name of the sub-directory into sources.mk.
To compile liboauth the system requires OpenSSL and libcurl. Therefore I added some GCC
options that references these libraries into the makeﬁle: -lssl -lcrypto -lcurl. Nevertheless, the libraries
used are those installed on my own system, not those speciﬁc to simulated FreeRTOS system, which
is not suitable for an embedded environment.
The best possibility could be to port OpenSSL and libcurl to FreeRTOS in order to make
liboauth totally independent of my system. These libraries are massive and require many research
to be ported, moreover that was not an immediate priority under the plan, so I chose to set aside
this issue until my Twitter library works.
1

A makeﬁle is a ﬁle containing compilation instructions.

16

5.2

Authentication process

Prior to determining the authentication process, I deﬁned the required informations to perform it as follows:
• The Consumer token allows to authorise a speciﬁc application to access data from Twitter.
• The user login and password prove this user allows the application to access to his timeline.
• The URL to send requests are static informations given by Twitter.
I chose to deﬁned the Consumer token and the user informations as parameters of the main authentication function. In this way, the developer will be able to chose which Twitter application and
which Twitter account would used by the library to access data. The URL are deﬁned as static ﬁelds
into the library.
Then, the ﬁrst step of the authentication is the use of the Consumer token given by Twitter to
get the Request token. Whatever the request, the URL and sometimes the parameters are generated
into a speciﬁc function according to the Twitter speciﬁcations. For this ﬁrst stage:
1
2

t w i t t e r r e q u e s t t o k e n u r l ( consumer key , c o n s u m e r s e c r e t , &r e q u e s t t o k e n u r l ) ;
t w i t t e r r e q u e s t t o k e n ( r e q u e s t t o k e n u r l , &r e q u e s t t o k e n k e y , &r e q u e s t t o k e n s e c r e t , &
callback ) ;

Basically, the output parameters begin by the & symbol because I assign the result values to the speciﬁed variables, so I need to know its references. For instance, the ﬁrst function use the consumer key
and the consumer secret to get the generated request token url . And the second one use the
request token url value to return the request token key , the request token secret and the
callback .
The Veriﬁer step is probably the most important but also the more complex. As usual, the
URL is generated by a function and then the request is sent by another one:
1
2

t w i t t e r d i r e c t t o k e n u r l ( r e q u e s t t o k e n k e y , &d i r e c t t o k e n u r l ) ;
t w i t t e r v e r i f i e r ( d i r e c t t o k e n u r l , request token key , &v e r i f i e r ) ;

But the twitter verifier function is divided into several steps:
• Send a HTTP GET request using OAuth: oauth http get() .
• Parse the HTML result of the request and get the authenticity code using
twitter direct token authenticity() .
• Regenerate another URL and some parameters using the authenticity code, and the user account informations through twitter direct token url2() .
• Send a HTTP POST request using the OAuth with the new URL and the generated parameters:
oauth http post() .
17

• Parse the HTML result of the request and get the ﬁnal PIN code (or veriﬁer) with
twitter direct token pin() .
The ﬁnal step of the authentication is to obtaining the Access token:
1

2

t w i t t e r a c c e s s t o k e n u r l ( consumer key , c o n s u m e r s e c r e t , r e q u e s t t o k e n k e y ,
r e q u e s t t o k e n s e c r e t , v e r i f i e r , &a c c e s s t o k e n u r l ) ;
t w i t t e r a c c e s s t o k e n ( a c c e s s t o k e n u r l , &a c c e s s t o k e n k e y , &a c c e s s t o k e n s e c r e t , &
a c c e s s t o k e n u s e r n a m e , &a c c e s s t o k e n u s e r i d ) ;

These functions use the two ﬁrst tokens (Consumer and Request) and the Veriﬁer to obtain the ﬁnal
token which could be use as a proof of user authenticity and user allowance about data accessing
from his timeline.
Finally, the main function gives to the developer a C entity (typed as a structure) call
twitterAuthEntity deﬁned with the following ﬁelds:
•
•
•
•

5.3

The
The
The
The

user screen name.
user identiﬁer.
Access token key.
Access token secret.

Send a tweet

- How use the authentication structure - Apply these informations to a behaviour

5.4

Receive a tweet

- Receiving process - XML parsing: get each tweet - Store temporary informations as a structure

18

6

Testing of the library

19

7

Evaluation of the project

7.1

Goal

(Is my goal achieved, why/why not?)
(Is my work could be use by someone else, why/why not?)

7.2

Schedule

(Did I follow my schedule, why/why not?)

7.3

Improvements

(What is it possible to do to improve my library?)

20

8

Conclusion

21

Bibliography
[1]
[2]
[3]
[4]
[5]
[6]

Robin Gareus. liboauth. http://liboauth.sourceforge.net.
GitHub. Github, social coding. https://github.com.
Real Time Engineers ltd. Freertos website. http://www.freertos.org.
The OpenSSL Project. Openssl. http://www.openssl.org.
Daniel Stenberg. libcurl. http://curl.haxx.se.
Twitter. Developers documentation. https://dev.twitter.com/docs.

22

